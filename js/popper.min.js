/ **
 * @ popperjs / core v2.9.3 - Licencia MIT
 * /

"use estricto";! function (e, t) {"object" == typeof export && "undefined"! = typeof module? t (export): "function" == typeof define && define.amd? define (["export"] , t): t ((e = "undefined"! = typeof globalThis? globalThis: e || self) .Popper = {})} (this, (function (e) {function t (e) {return null == e? window: "[object Window]"! == e.toString ()? (e = e.ownerDocument) && e.defaultView || window: e} function n (e) {return e instanceof t (e) .Element || e instancia de elemento} función o (e) {devuelve e instancia de t (e) .HTMLElement || e instancia de HTMLElement} función r (e) {devuelve "indefinido"! = tipo de ShadowRoot && (e instancia de t (e) .ShadowRoot || e instancia de ShadowRoot)} función i (e, t) {void 0 === t && (t =! 1); var n = e.getBoundingClientRect (), r = 1, i = 1; return o (e) && t && (r = n. ancho / e.offsetWidth || 1, i = n.height / e.offsetHeight || 1), {width: q (n.width / r), height: q (n.height / i), top: q (n.top/ i), derecha: q (n. derecha / r), abajo: q (n. abajo / i), izquierda: q (n. izquierda / r), x: q (n. izquierda / r), y: q (n.top/i)}}function a (e) {return {scrollLeft: (e = t (e)). pageXOffset, scrollTop: e.pageYOffset}} function s (e) {return e? (e.nodeName || ""). toLowerCase (): null} function f (e) {return ((n (e)? e.ownerDocument: e.document) || window.document) .documentElement} function p (e) {return i (f (e)). left + a (e) .scrollLeft} function c (e) {return t (e) .getComputedStyle (e)} function l (e) {return e = c (e), / auto | scroll | overlay | hidden / .test (e.overflow + e.overflowY + e.overflowX)} función u (e, n, r) {void 0 === r && (r =! 1); var c, u = o (n); if (c = o (n)) {var d = (c = n.getBoundingClientRect ()). height / n.offsetHeight || 1; c = 1! == (c.width / n .offsetWidth || 1) || 1! == d} d = c, c = f (n), e = i (e, d), d = {scrollLeft: 0, scrollTop: 0}; var h = { x: 0, y: 0};return (u ||! u &&! r) && (("body"! == s (n) || l (c)) && (d = n! == t (n) && o (n)? {scrollLeft: n.scrollLeft, scrollTop: n.scrollTop}: a (n)), o (n)? ((h = i (n,! 0)). x + = n.clientLeft, h.y + = n.clientTop): c && (hx = p (c))), {x: e.left + d.scrollLeft-hx, y: e.top + d.scrollTop-hy, width: e.width, height: e.height}} función d (e) {var t = i (e), n = e.offsetWidth, o = e.offsetHeight; return 1> = Math.abs (t.width-n) && (n = t.width), 1> = Math.abs (t.height-o) && (o = t.height), {x: e.offsetLeft, y: e.offsetTop, width: n, height: o}} función h (e) {return " html "=== s (e)? e: e.assignedSlot || e.parentNode || (r (e)? e.host: null) || f (e)} función m (e) {return 0 < = ["html", "cuerpo", "# documento"]. indexOf (s (e))? e.ownerDocument.body: o (e) && l (e)? e: m (h (e))} función v (e, n) {var o; void 0 === n && (n = []); var r = m (e); return e = r === (null == (o = e.ownerDocument)? void 0: o.body), o = t (r), r = e? [o] .concat (o.visualViewport || [], l (r)? r: []): r, n = n.concat (r), e? n: n.concat (v (h (r)))} function g (e) {return o (e) && "fixed"! == c (e) .position? e.offsetParent: null} function y (e) {for (var n = t (e), r = g (e); r && 0 <= ["table", "td", "th"]. indexOf (s ( r)) && "static" === c (r) .position;) r = g (r); if (r && ("html" === s (r) || "body" === s (r ) && "static" === c (r) .position)) return n; if (! r) e: {if (r = -1! == navigator.userAgent.toLowerCase (). indexOf ("firefox") , -1 === navigator.userAgent.indexOf ("Trident") ||! O (e) || "Fixed"! == c (e) .position) for (e = h (e); o (e ) && 0> ["html", "cuerpo"]. IndexOf (s (e));) {var i = c (e); if ("none"! == i.transform || "none"! == i.perspectiva || "pintar" === i.contener || -1! == ["transformar", "perspectiva"]. indexOf (i.willChange) || r && "filter" === i.willChange || r && i.filter && "none"! == i.filter ) {r = e; break e} e = e.parentNode} r = null} return r || n} function b (e) {function t (e) {o.add (e.name), []. concat (e.requires || [], e.requiresIfExists || []). forEach ((function (e) {o.has (e) || (e = n.get (e)) && t (e)}) ), r.push (e)} var n = new Map, o = new Set, r = []; return e.forEach ((function (e) {n.set (e.name, e)})), e.forEach ((function (e) {o.has (e.name) || t (e)})), r} function w (e) {var t; return function () {return t || (t = new Promise ((function (n) {Promise.resolve (). then ((function () {t = void 0, n (e ())}))}))), t}} función x (e) {return e.split ("-") [0]} función O (e, t) {var n = t.getRootNode && t.getRootNode (); if (e.contains (t)) return! 0; if (n && r ( n)) hacer {if (t && e.isSameNode (t)) return! 0; t = t.parentNode || t.host} while (t); return! 1} function j (e) {return Object.assign ({}, e, {left: ex, top: ey, right: e.x + e.width , parte inferior: e.y + e.height})} función E (e, n) {if ("viewport" === n) {n = t (e); var r = f (e); n = n .visualViewport; var s = r.clientWidth; r = r.clientHeight; var l = 0, u = 0; n && (s = n.width, r = n.height, / ^ ((?! chrome | android). ) * safari / i.test (navigator.userAgent) || (l = n.offsetLeft, u = n.offsetTop)), e = j (e = {ancho: s, alto: r, x: l + p ( e), y: u})} else o (n)? ((e = i (n)). top + = n.clientTop, e.left + = n.clientLeft, e.bottom = e.top + n.clientHeight , e.right = e.left + n.clientWidth, e.width = n.clientWidth, e.height = n.clientHeight, ex = e.left, ey = e.top) :( u = f (e), e = f (u), s = a (u), n = null == (r = u.ownerDocument)? void 0: r.body, r = U (e.scrollWidth, e.clientWidth, n? n. scrollWidth: 0, n? n.clientWidth: 0), l = U (e.scrollHeight, e.clientHeight, n? n.scrollHeight: 0, n? n.clientHeight: 0), u = -s.scrollLeft + p (u), s = -s.scrollTop,"rtl" === c (n || e) .direction && (u + = U (e.clientWidth, n? n .clientWidth: 0) -r), e = j ({width: r, height: l, x : u, y: s})); return e} function D (e, t, r) {return t = "clippingParents" === t? function (e) {var t = v (h (e)), r = 0 <= ["absoluto", "fijo"]. indexOf (c (e) .position) && o (e)? y (e): e; return n (r)? t.filter ((function (e ) {return n (e) && O (e, r) && "cuerpo"! == s (e)})): []} (e): []. concat (t), (r = (r = [ ] .concat (t, [r])). reduce ((function (t, n) {return n = E (e, n), t.top = U (n.top, t.top), t.right = z (n.derecha, t.derecha), t.bottom = z (n.bottom, t.bottom), t.izquierda = U (n.izquierda, t.izquierda), t}), E (e, r [0]))). width = r.right-r. left, r.height = r.bottom-r.top, rx = r.left, ry = r.top, r} function L (e) { return 0 <= ["top", "bottom"]. indexOf (e)? "x": "y"} función M (e) {var t = e.reference, n = e.element, o = (e = e.colocación)? x (e): nulo; e = e? e.split ("-") [1]: nulo; var r = t.x + t.width / 2-n.width / 2, i = t.y + t.height / 2-n .height / 2; cambiar (o) {caso "arriba": r = {x: r, y: ty-n. altura}; descanso; caso "abajo": r = {x: r, y: t.y + t.altura}; break; case "right": r = {x: t.x + t.width, y: i}; break; case "left": r = {x: tx-n .width, y: i}; break; predeterminado: r = {x: tx, y: ty}} if (null! = (o = o? L (o): null)) switch (i = "y" === o? "height": "width ", e) {case" start ": r [o] - = t [i] / 2-n [i] / 2; break; case" end ": r [o] + = t [i] / 2- n [i] / 2} return r} función P (e) {return Object.assign ({}, {top: 0, right: 0, bottom: 0, left: 0}, e)} function k (e, t) {return t.reduce ((function (t, n) {return t [n] = e, t}), {})} function W (e, t) {void 0 === t && (t = { }); var o = t; t = void 0 === (t = o.placement)? e.placement: t; var r = o.boundary, a = void 0 === r? "clippingParents": r , s = void 0 === (r = o.rootBoundary)? "viewport": r;r = vacío 0 === (r = o.elementContext)? "popper": r; var p = o.altBoundary, c = vacío 0! == p && p; o = P ("número"! = tipo de (o = vacío 0 === (o = o.padding)? 0: o)? o: k (o, N)); var l = e.elements.reference; p = e.rects.popper, a = D (n (c = e.elements [c? "popper" === r? "reference": "popper": r])? c: c.contextElement || f (e.elements.popper), a, s), c = M ({referencia: s = i (l), elemento: p, estrategia: "absoluta", ubicación: t}), p = j (Object.assign ({}, p, c)), s = " popper "=== r? p: s; var u = {top: a.top-s.top + o.top, bottom: s.bottom-a.bottom + o.bottom, left: a.left-s .izquierda + o.izquierda, derecha: s.right-a.right + o.right}; if (e = e.modifiersData.offset, "popper" === r && e) {var d = e [t]; Object .keys (u) .forEach ((function (e) {var t = 0 <= ["right", "bottom"]. indexOf (e)? 1: -1, n = 0 <= ["top", "inferior"]. indexOf (e)? "y": "x";u [e] + = d [n] * t}))} return u} función A () {para (var e = argumentos.length, t = Array (e), n = 0; n <e; n ++) t [n] = argumentos [n]; return! t.some ((function (e) {return! (e && "function" == typeof e.getBoundingClientRect)}))} función B (e) {void 0 == = e && (e = {}); var t = e.defaultModifiers, o = void 0 === t? []: t, r = void 0 === (e = e.defaultOptions)? X: e; return function (e, t, i) {function a () {f.forEach ((function (e) {return e ()})), f = []} void 0 === i && (i = r); var s = {ubicación: "inferior", ordenadoModificadores: [], opciones: Object.assign ({}, X, r), modifiersData: {}, elementos: {referencia: e, popper: t}, atributos: {}, estilos: {}}, f = [], p =! 1, c = {estado: s, setOptions: function (i) {return a (), s.options = Object.assign ({}, r, s. opciones, i), s.scrollParents = {referencia: n (e)? v (e): e.contextElement? v (e.contextElement): [], popper: v (t)}, i = función (e) {var t = b (e); return _.reduce ((function (e, n) {return e.concat (t.filter ((function (e) {return e.phase === n})))}), [])} (function (e) {var t = e.reduce ((function (e, t) {var n = e [t.name]; return e [t.name] = n? Object.assign ({}, n, t, {opciones: Object.assign ({}, n.options, t.options), datos: Object.assign ({}, n.data, t.data)}): t, e}), {}); return Object.keys (t) .map ((function (e) {return t [e]} ))} ([]. concat (o, s.options.modifiers))), s.orderedModifiers = i.filter ((function (e) {return e.enabled})), s.orderedModifiers.forEach ((function (e) {var t = e.name, n = e.options; n = void 0 === n? {}: n, "function" == typeof (e = e.effect) && (t = e ( {estado: s, nombre: t, instancia: c, opciones: n}), f.push (t || función () {}))})), c.update ()}, forceUpdate: función () { if (! p) {var e = s.elements, t = e.reference; if (A (t, e = e.popper)) for (s.rects = {reference: u (t, y (e), "fijo" === s.options.strategy), popper: d (e)}, s.reset =! 1, s.placement = s.options.placement, s.orderedModifiers.forEach ((function (e) {return s.modifiersData [e.name] = Object.assign ({}, e.data)})), t = 0; t <s.orderedModifiers.length; t ++) if (! 0 === s.reset) s.reset =! 1, t = -1; else {var n = s.orderedModifiers [t]; e = n.fn; var o = n.options; o = void 0 = == o? {}: o, n = n. nombre, "función" == tipo de e && (s = e ({estado: s, opciones: o, nombre: n, instancia: c}) || s)} }}, actualizar: w ((función () {devolver nueva promesa ((función (e) {c.forceUpdate (), e (s)}))})), destruir: función () {a (), p =! 0}}; return A (e, t)? (C.setOptions (i). Then ((function (e) {! P && i.onFirstUpdate && i.onFirstUpdate (e)})), c): c}} función H (e) {var n, o = e.popper, r = e.popperRect, i = e.placement, a = e.offsets, s = e.position, p = por ejemplo, puAcceleration, l = e.adaptive; if (! 0 === (e = e.roundOffsets)) {e = ay; var u = window.devicePixelRatio || 1; e = {x: F (F (ax * u) / u) || 0, y: F (F (e * u) / u) || 0}} más e = "función" == tipo de e? e (a): a; e = vacío 0 === (e = (u = e ) .x)? 0: e,u = vacío 0 === (u = uy)? 0: u; var d = a.hasOwnProperty ("x"); a = a.hasOwnProperty ("y"); var h, m = "left", v = "superior", g = ventana; if (l) {var b = y (o), w = "clientHeight", x = "clientWidth"; b === t (o) && ("static"! == c (b = f (o)). posición && (w = "scrollHeight", x = "scrollWidth")), "top" === i && (v = "bottom", u- = b [w] -r. altura, u * = p? 1: -1), "izquierda" === i && (m = "derecha", e- = b [x] -r.width, e * = p? 1: -1)} return o = Object.assign ({position: s}, l && K), p? Object.assign ({}, o, ((h = {}) [v] = a? "0": "", h [m ] = d? "0": "", h.transform = 2> (g.devicePixelRatio || 1)? "translate (" + e + "px," + u + "px)": "translate3d (" + e + " px, "+ u +" px, 0) ", h)): Object.assign ({}, o, ((n = {}) [v] = a? u +"px ":" ", n [m] = d? e +" px ":" ", n.transform =" ", n))} función T (e) {return e.replace (/ left | right | bottom | top / g, (function (e) {return ee [e]}))} function R (e) {return e.replace (/ start | end / g, (function (e) {return te [e]}) )} función S (e, t, n) {return void 0 === n && (n = {x: 0, y: 0}), {top: e.top-t.height-ny, right: e. right-t.width + nx, bottom: e.bottom-t.height + ny, left: e.left-t.width-nx}} función C (e) {return ["top", "right", " bottom "," left "]. some ((function (t) {return 0 <= e [t]}))} var q = Math.round, N = [" top "," bottom "," right ", "left"], V = N.reduce ((function (e, t) {return e.concat ([t + "- start", t + "- end"])}), []), I = []. concat (N, ["auto"]). reduce ((function (e, t) {return e.concat ([t, t + "- inicio", t + "- fin"])}), []), _ = "beforeRead read afterRead beforeMain main afterMain beforeWrite write afterWrite ".split (" "), U = Math.max, z = Math.min, F = Math.round, X = {ubicación:" bottom ", modificadores: [], estrategia : "absoluto"}, Y = {pasivo:! 0}, G = {nombre: "eventListeners", habilitado:! 0, fase: "escribir", fn: función () {}, efecto: función (e) { var n = e.state, o = e.instance, r = (e = e.options) .scroll, i = void 0 === r || r, a = void 0 === (e = e.resize ) || e, s = t (n.elements.popper), f = []. concat (n.scrollParents.reference, n.scrollParents.popper); return i && f.forEach ((function (e) {e.addEventListener ("scroll", o.update, Y)})), a && s.addEventListener ("resize", o.update, Y), function () {i && f.forEach ((function (e) {e.removeEventListener ("scroll ", o.update, Y)})), a && s.removeEventListener (" resize ", o.update, Y)}}, data: {}}, J = {nombre:"popperOffsets", habilitado:! 0, fase: "leer", fn: función (e) {var t = e.state; t.modifiersData [e.name] = M ({referencia: t.rects.reference, element : t.rects.popper, estrategia: "absoluta", ubicación: t.placement})}, datos: {}}, K = {arriba: "auto", derecha: "auto", abajo: "auto", izquierda : "auto"}, Q = {nombre: "computeStyles", habilitado:! 0, fase: "beforeWrite", fn: function (e) {var t = e.state, n = e.options; e = void 0 === (e = n.gpuAcceleration) || e; var o = n.adaptive; o = void 0 === o || o, n = void 0 === (n = n. RoundOffsets) || n , e = {ubicación: x (t.placement), popper: t.elements.popper, popperRect: t.rects.popper, gpuAcceleration: e}, null! = t.modifiersData.popperOffsets && (t.styles.popper = Object .assign ({}, t.styles.popper, H (Object.assign ({}, e, {compensaciones: t.modifiersData.popperOffsets, posición: t.options.strategy, adaptive: o, roundOffsets: n})) )),¡nulo!= t.modifiersData.arrow && (t.styles.arrow = Object.assign ({}, t.styles.arrow, H (Object.assign ({}, e, {compensaciones: t.modifiersData.arrow, posición: "absoluta ", adaptive:! 1, roundOffsets: n})))), t.attributes.popper = Object.assign ({}, t.attributes.popper, {" data-popper-position ": t.placement})} , datos: {}}, Z = {nombre: "applyStyles", habilitado:! 0, fase: "escribir", fn: función (e) {var t = e.state; Object.keys (t.elements). paraCada ((función (e) {var n = t.styles [e] || {}, r = t.attributes [e] || {}, i = t.elements [e]; o (i) && s ( i) && (Object.assign (i.style, n), Object.keys (r) .forEach ((function (e) {var t = r [e] ;! 1 === t? i.removeAttribute (e ): i.setAttribute (e,! 0 === t? "": t)})))}))}, efecto: function (e) {var t = e.state, n = {popper: {position : t.options.strategy, izquierda: "0", arriba: "0", margen: "0"}, flecha: {posición: "absoluta"},referencia: {}}; return Object.assign (t.elements.popper.style, n.popper), t.styles = n, t.elements.arrow && Object.assign (t.elements.arrow.style, n. flecha) , function () {Object.keys (t.elements) .forEach ((function (e) {var r = t.elements [e], i = t.attributes [e] || {}; e = Object.keys (t.styles.hasOwnProperty (e)? t.styles [e]: n [e]). reduce ((function (e, t) {return e [t] = "", e}), {}), o (r) && s (r) && (Object.assign (r.style, e), Object.keys (i) .forEach ((function (e) {r.removeAttribute (e)})))}))} }, requiere: ["computeStyles"]}, $ = {nombre: "offset", habilitado:! 0, fase: "main", requiere: ["popperOffsets"], fn: function (e) {var t = e .state, n = e.name, o = void 0 === (e = e.options.offset)? [0,0]: e, r = (e = I.reduce ((función (e, n) {var r = t.rects, i = x (n), a = 0 <= ["left", "top"]. indexOf (i)? - 1: 1, s = "function" == typeof o? o (Object.assign ({},r, {ubicación: n})): o; return r = (r = s [0]) || 0, s = ((s = s [1]) || 0) * a, i = 0 <= ["izquierda", "derecha"]. indexOf (i)? {x: s, y: r}: {x: r, y: s}, e [n] = i, e}), {})) [t.placement], i = rx; r = ry, null! = t.modifiersData.popperOffsets && (t.modifiersData.popperOffsets.x + = i, t.modifiersData.popperOffsets.y + = r), t.modifiersData [n] = e}}, ee = {left: "right", right: "left", bottom: "top", top: "bottom"}, te = {start: "end", end: "start"}, ne = {nombre: "flip", habilitado:! 0, fase: "principal", fn: función (e) {var t = e.state, n = e.options; if (e = e.name,! t. modifiersData [e] ._ skip) {var o = n.mainAxis; o = void 0 === o || o; var r = n.altAxis; r = void 0 === r || r; var i = n .fallbackPlacements, a = n.padding, s = n.boundary, f = n.rootBoundary, p = n.altBoundary, c = n.flipVariations, l = void 0 === c || c, u = n.allowedAutoPlacements ; c = x (n = t.opciones.colocación), i = i || (c! == n && l? function (e) {if ("auto" === x (e)) return []; var t = T (e); return [R (e), t, R (t)]} (n) : [T (n)]); var d = [n] .concat (i) .reduce ((function (e, n) {return e.concat ("auto" === x (n)? Function (e , t) {void 0 === t && (t = {}); var n = t.boundary, o = t.rootBoundary, r = t.padding, i = t.flipVariations, a = t.allowedAutoPlacements, s = vacío 0 === a? I: a, f = t.placement.split ("-") [1]; 0 === (i = (t = f? i? V: V.filter ((función ( e) {return e.split ("-") [1] === f})): N) .filter ((function (e) {return 0 <= s.indexOf (e)}))). length && (i = t); var p = i.reduce ((function (t, i) {return t [i] = W (e, {ubicación: i, límite: n, límite raíz: o, relleno: r}) [ x (i)], t}), {}); return Object.keys (p) .sort ((function (e, t) {return p [e] -p [t]}))} (t, { location: n, boundary: s, rootBoundary: f, padding: a, flipVariations: l, allowedAutoPlacements: u}): n)}), []); n = t.rects.reference, i = t.rects.popper ; var h = nuevo mapa; c =! 0;para (var m = d [0], v = 0; v <d.length; v ++) {var g = d [v], y = x (g), b = "start" === g.split ( "-") [1], w = 0 <= ["arriba", "abajo"]. IndexOf (y), O = w? "Width": "height", j = W (t, {ubicación: g , boundary: s, rootBoundary: f, altBoundary: p, padding: a}); if (b = w? b? "right": "left": b? "bottom": "top", n [O]> i [O] && (b = T (b)), O = T (b), w = [], o && w.push (0> = j [y]), r && w.push (0> = j [b] , 0> = j [O]), w.every ((function (e) {return e}))) {m = g, c =! 1; break} h.set (g, w)} if (c ) for (o = function (e) {var t = d.find ((function (t) {if (t = h.get (t)) return t.slice (0, e) .every ((function (e) ) {return e}))})); if (t) return m = t, "break"}, r = l? 3: 1; 0 <r && "break"! == o (r); r-- ); t.placement! == m && (t.modifiersData [e] ._ skip =! 0, t.placement = m, t.reset =! 0)}}, requireIfExists: ["offset"], data:{_skip:! 1}}, oe = {name: "preventOverflow", enabled:! 0, phase: "main", fn: function (e) {var t = e.state, n = e.options; e = e.name; var o = n.MainAxis, r = void 0 === o || o, i = void 0! == (o = n.altAxis) && o; o = void 0 === (o = n .tether) || o; var a = n.tetherOffset, s = void 0 === a? 0: a, f = W (t, {boundary: n.boundary, rootBoundary: n.rootBoundary, padding: n. padding, altBoundary: n.altBoundary}); n = x (t.placement); var p = t.placement.split ("-") [1], c =! p, l = L (n); n = "x" === l? "y": "x", a = t.modifiersData.popperOffsets; var u = t.rects.reference, h = t.rects.popper, m = "function" == typeof s ? s (Object.assign ({}, t.rects, {ubicación: t.placement})): s; if (s = {x: 0, y: 0}, a) {if (r || i) {var v = "y" === l? "top": "left", g = "y" === l? "bottom": "right", b = "y" === l? "height ":" ancho ", w = a [l],O = a [l] + f [v], j = a [l] -f [g], E = o? -H [b] / 2: 0, D = "inicio" === p? U [ b]: h [b]; p = "inicio" === p? -h [b]: - u [b], h = t.elements.arrow, h = o && h? d (h): {ancho: 0, altura: 0}; var M = t.modifiersData ["arrow # persistent"]? T.modifiersData ["arrow # persistent"]. Padding: {top: 0, right: 0, bottom: 0, left: 0 }; v = M [v], g = M [g], h = U (0, z (u [b], h [b])), D = c? u [b] / 2-Ehvm: Dhvm , u = c? -u [b] /2+E+h+g+m:p+h+g+m,c=t.elements.arrow&&y (t.elements.arrow), m = t.modifiersData. offset? t.modifiersData.offset [t.placement] [l]: 0, c = a [l] + Dm- (c? "y" === l? c.clientTop || 0: c.clientLeft || 0: 0), u = a [l] + um, r && (r = o? Z (O, c): O, j = o? U (j, u): j, r = U (r, z ( w, j)), a [l] = r, s [l] = rw), i && (r = (i = a [n]) + f ["x" === l? "top": "izquierda "], f = if [" x "=== l?" bottom ":" right "], r = o? z (r, c): r, o = o? U (f, u): f, o = U (r, z (i, o)), a [n] = o, s [n] = oi)} t.modifiersData [e] = s}}, requireIfExists: ["offset"]}, re = {name: "arrow", enabled:! 0, phase: "main", fn: function (e) {var t, n = e.state, o = e.name, r = e.options, i = n.elements.arrow, a = n.modifiersData.popperOffsets, s = x (n. lugar); if (e = L (s), s = 0 <= ["left", "right"]. indexOf (s)? "height": "width", i && a) {r = P ("number"! = typeof (r = "function" == typeof (r = r.padding)? r (Object.assign ({}, n.rects, {location: n.placement})): r)? r: k (r, N)); var f = d (i ), p = "y" === e? "top": "left", c = "y" === e? "bottom": "right", l = n.rects.reference [s] + n .rects.reference [e] -a [e] -n.rects.popper [s]; a = a [e] -n.rects.reference [e], a = (i = (i = y (i) )? "y" === e? i.clientHeight || 0: i.clientWidth || 0: 0) / 2-f [s] / 2 + (l / 2-a / 2), s = U ( r [p], z (a, si [s] -r [c])), n.modifiersData [o] = ((t = {}) [e] = s, t.centerOffset = sa, t)}}, efecto: function (e) {var t = e.state; if (null! = (e = void 0 === (e = e.options.element)? "[data-popper-arrow]": e)) {if ("string" == typeof e &&! (e = t.elements.popper.querySelector (e))) return; O (t.elements.popper, e) && (t.elements.arrow = e)}}, requiere: ["popperOffsets"], requireIfExists: ["preventOverflow"]}, ie = { nombre: "ocultar", habilitado:! 0, fase: "principal", requireIfExists: ["preventOverflow"], fn: función (e) {var t = e.state; e = e.name; var n = t. rects.reference, o = t.rects.popper, r = t.modifiersData.preventOverflow, i = W (t, {elementContext: "reference"}), a = W (t, {altBoundary:! 0}); n = S (i, n), o = S (a, o, r), r = C (n), a = C (o), t.modifiersData [e] = {referenceClippingOffsets: n, popperEscapeOffsets: o, isReferenceHidden : r, hasPopperEscaped: a}, t.attributes.popper = Objeto.asignar ({}, t.attributes.popper, {"data-popper-reference-hidden": r, "data-popper-escaped": a})}}, ae = B ({defaultModifiers: [G, J, Q, Z]}), se = [G, J, Q, Z, $, ne, oe, re, ie], fe = B ({defaultModifiers: se}); e.applyStyles = Z, e.arrow = re, e.computeStyles = Q, e.createPopper = fe, e.createPopperLite = ae, e.defaultModifiers = se, e.detectOverflow = W, e.eventListeners = G, e.flip = ne, e.hide = ie, e.offset = $, e.popperGenerator = B, e.popperOffsets = J, e.preventOverflow = oe, Object.defineProperty (e, "__ esModule", {valor:! 0})}));e.offset = $, e.popperGenerator = B, e.popperOffsets = J, e.preventOverflow = oe, Object.defineProperty (e, "__ esModule", {valor:! 0})}));e.offset = $, e.popperGenerator = B, e.popperOffsets = J, e.preventOverflow = oe, Object.defineProperty (e, "__ esModule", {valor:! 0})}));
// # sourceMappingURL = popper.min.js.map